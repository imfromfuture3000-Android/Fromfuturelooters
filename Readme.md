LootBot Zero — 10× Smarter, 0× Cost

Mission: a modular, ethical "lootbot" that continuously finds and delivers free, legitimate opportunities (airdrops you can claim ethically, testnet reward programs, dev bounties, grants, hackathons, open-source paid issues, freebies & learning stipends) — using only free tools.

> Built to run entirely on GitHub Actions (free tier) + deliver to Telegram and/or Discord. No servers, no paid APIs, no database bills.




---

1) Features at a Glance

Modular sources (plug-in style): crypto airdrops (public RSS/APIs only), testnet incentives, hackathons, Gitcoin-style grants, OSS bounties, scholarships/stipends, freebies/deals.

Smart dedupe via local SQLite; avoids reposts.

Priority scoring (freshness, reputation, social proof, deadline proximity) to rank.

Rate-limit & TOS safe: uses RSS, public endpoints, and polite intervals; no CAPTCHA bypass, no multi-account farming.

Instant alerts to Telegram or Discord with deep links and quick facts.

Static web feed (JSON) published to GitHub Pages for browsing/searching.

Config-as-code via .env (or GitHub Action Secrets).



---

2) Repo Layout

lootbot-zero/
├─ src/
│  ├─ main.py
│  ├─ config.py
│  ├─ scoring.py
│  ├─ model.py
│  ├─ utils/
│  │  ├─ db.py
│  │  ├─ rss.py
│  │  ├─ http.py
│  │  └─ text.py
│  ├─ notifiers/
│  │  ├─ telegram.py
│  │  └─ discord.py
│  └─ sources/
│     ├─ crypto_airdrops.py
│     ├─ grants_and_bounties.py
│     ├─ hackathons.py
│     ├─ freebies_general.py
│     └─ sample_custom.py
├─ web/
│  ├─ index.html
│  └─ feed.json        # auto-generated by CI
├─ scripts/
│  ├─ run_local.sh
│  └─ build_feed.py
├─ .github/
│  └─ workflows/
│     └─ lootbot.yml
├─ requirements.txt
├─ .env.example
├─ README.md
└─ LICENSE


---

3) Quick Start (Local)

# 1) Clone + enter
git clone https://github.com/<you>/lootbot-zero.git
cd lootbot-zero

# 2) Create venv
python -m venv .venv && source .venv/bin/activate

# 3) Install deps
pip install -r requirements.txt

# 4) Copy env and edit
cp .env.example .env
# add TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID or DISCORD_WEBHOOK_URL (one is enough)

# 5) Run
python -m src.main


---

4) Environment Vars (.env.example)

# One of these notification channels is enough
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=
DISCORD_WEBHOOK_URL=

# Optional tuning
MAX_ITEMS_PER_RUN=40
MIN_SCORE_TO_NOTIFY=0.55
JSON_FEED_PATH=web/feed.json
REPO_OWNER=
REPO_NAME=
GITHUB_PAGES_BRANCH=gh-pages

# Safety switches
ALLOW_AIRDROPS=true
ALLOW_GRANTS=true
ALLOW_HACKATHONS=true
ALLOW_FREEBIES=true
BLOCKLIST_WORDS=casino,adult,nsfw,


---

5) Python Core

src/model.py

from dataclasses import dataclass
from typing import Optional, Dict

@dataclass
class Item:
    source: str
    title: str
    url: str
    summary: str
    posted_at: Optional[str]  # ISO8601
    deadline: Optional[str]   # ISO8601
    tags: list[str]
    meta: Dict
    score: float = 0.0

src/utils/db.py

import sqlite3, hashlib, os
from contextlib import contextmanager

DB_PATH = os.environ.get("DB_PATH", ".lootbot.sqlite")

@contextmanager
def conn():
    c = sqlite3.connect(DB_PATH)
    try:
        yield c
    finally:
        c.commit()
        c.close()

def init_db():
    with conn() as c:
        c.execute("""
        CREATE TABLE IF NOT EXISTS items (
          id TEXT PRIMARY KEY,
          source TEXT,
          title TEXT,
          url TEXT,
          summary TEXT,
          posted_at TEXT,
          deadline TEXT,
          tags TEXT,
          meta TEXT,
          score REAL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
        """)

def make_id(source, url):
    return hashlib.sha256(f"{source}|{url}".encode()).hexdigest()

def seen(item_id):
    with conn() as c:
        cur = c.execute("SELECT 1 FROM items WHERE id=?", (item_id,))
        return cur.fetchone() is not None

def insert(item):
    with conn() as c:
        c.execute(
            "INSERT OR IGNORE INTO items (id, source, title, url, summary, posted_at, deadline, tags, meta, score) VALUES (?,?,?,?,?,?,?,?,?,?)",
            (
                make_id(item.source, item.url), item.source, item.title, item.url,
                item.summary, item.posted_at, item.deadline, ",".join(item.tags), str(item.meta), item.score
            ),
        )

src/utils/rss.py

import feedparser

def fetch_rss(url, max_items=50):
    feed = feedparser.parse(url)
    for e in feed.entries[:max_items]:
        yield {
            "title": e.get("title", ""),
            "link": e.get("link", ""),
            "summary": e.get("summary", ""),
            "published": getattr(e, "published", None) or getattr(e, "updated", None),
        }

src/utils/http.py

import requests, time

class Http:
    def __init__(self, timeout=20):
        self.timeout = timeout

    def get_json(self, url):
        r = requests.get(url, timeout=self.timeout, headers={"User-Agent": "lootbot-zero/1.0"})
        r.raise_for_status()
        time.sleep(0.5)  # be polite
        return r.json()

src/utils/text.py

import re, os

BLOCKLIST = set(w.strip().lower() for w in os.environ.get("BLOCKLIST_WORDS", "").split(",") if w.strip())

def clean(text: str) -> str:
    return re.sub(r"\s+", " ", (text or "").strip())

def allowed(text: str) -> bool:
    t = (text or "").lower()
    return not any(w in t for w in BLOCKLIST)

src/scoring.py

from datetime import datetime, timezone

def score_item(item):
    # basic scoring: freshness + explicit tags + deadline proximity
    s = 0.0
    now = datetime.now(timezone.utc)

    # Freshness bonus
    try:
        if item.posted_at:
            posted = datetime.fromisoformat(item.posted_at.replace("Z", "+00:00"))
            age_hours = (now - posted).total_seconds() / 3600
            if age_hours < 6: s += 0.45
            elif age_hours < 24: s += 0.35
            elif age_hours < 72: s += 0.2
    except Exception:
        pass

    # Deadline proximity
    try:
        if item.deadline:
            dl = datetime.fromisoformat(item.deadline.replace("Z", "+00:00"))
            days = (dl - now).days
            if 0 <= days <= 14: s += 0.2
    except Exception:
        pass

    # Tag weight
    tag_weight = {"grant":0.2, "bounty":0.25, "airdrop":0.25, "hackathon":0.2, "freebie":0.1}
    s += sum(tag_weight.get(t, 0.05) for t in item.tags[:4])

    return min(1.0, s)

src/notifiers/telegram.py

import os, requests

TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHAT = os.getenv("TELEGRAM_CHAT_ID")

def enabled():
    return bool(TOKEN and CHAT)

def send(text):
    if not enabled():
        return
    url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
    payload = {"chat_id": CHAT, "text": text, "disable_web_page_preview": True}
    requests.post(url, json=payload, timeout=20)

src/notifiers/discord.py

import os, requests

WEBHOOK = os.getenv("DISCORD_WEBHOOK_URL")

def enabled():
    return bool(WEBHOOK)

def send(text):
    if not enabled():
        return
    requests.post(WEBHOOK, json={"content": text}, timeout=20)

src/sources/crypto_airdrops.py

from datetime import datetime, timezone
from src.model import Item
from src.utils.rss import fetch_rss
from src.utils.text import clean, allowed

# Example public RSS-like sources (use ethical, legit content only)
FEEDS = [
    # Add reputable project/blog RSS feeds that announce testnets or user rewards
    "https://blog.solana.com/feed.xml",
    "https://ethereum.org/en/developers/rss.xml",  # example; adjust to your stack
]

# You can also point to community-maintained airdrop calendars that export RSS.


def run(max_items=40):
    out: list[Item] = []
    for url in FEEDS:
        for e in fetch_rss(url, max_items=max_items):
            title = clean(e.get("title"))
            link = e.get("link")
            if not (title and link):
                continue
            if not allowed(title):
                continue
            summary = clean(e.get("summary"))
            posted = None
            if e.get("published"):
                try:
                    posted = datetime.fromisoformat(e["published"]).astimezone(timezone.utc).isoformat()
                except Exception:
                    posted = None

            tags = []
            t = title.lower()
            if any(k in t for k in ["testnet", "incentive", "reward", "airdrop"]):
                tags.append("airdrop")

            out.append(Item(
                source="crypto_rss",
                title=title,
                url=link,
                summary=summary,
                posted_at=posted,
                deadline=None,
                tags=tags or ["update"],
                meta={"feed": url},
            ))
    return out

src/sources/grants_and_bounties.py

from src.model import Item
from src.utils.rss import fetch_rss
from src.utils.text import clean, allowed

FEEDS = [
    # Gitcoin Grants announcements RSS (example placeholder; add real RSS endpoints you trust)
    "https://gitcoin.co/blog/rss.xml",
    # Open Source bounties from well-known orgs via blog/feed
    "https://opensource.googleblog.com/feeds/posts/default",  
]

def run(max_items=40):
    items = []
    for url in FEEDS:
        for e in fetch_rss(url, max_items=max_items):
            title = clean(e.get("title"))
            link = e.get("link")
            if not (title and link) or not allowed(title):
                continue
            items.append(Item(
                source="grants_rss",
                title=title,
                url=link,
                summary=clean(e.get("summary")),
                posted_at=None,
                deadline=None,
                tags=["grant" if "grant" in title.lower() else "bounty"],
                meta={"feed": url},
            ))
    return items

src/sources/hackathons.py

from src.model import Item
from src.utils.rss import fetch_rss
from src.utils.text import clean

FEEDS = [
    # Example: Devpost/Hackathon blogs that have RSS; replace with ones you follow
    "https://devpost.com/feed/projects/popular",  # informational; many sources publish RSS
]

def run(max_items=40):
    items = []
    for url in FEEDS:
        for e in fetch_rss(url, max_items=max_items):
            title = clean(e.get("title"))
            link = e.get("link")
            if not (title and link):
                continue
            items.append(Item(
                source="hackathons_rss",
                title=title,
                url=link,
                summary=clean(e.get("summary")),
                posted_at=None,
                deadline=None,
                tags=["hackathon"],
                meta={"feed": url},
            ))
    return items

src/sources/freebies_general.py

from src.model import Item
from src.utils.rss import fetch_rss
from src.utils.text import clean, allowed

FEEDS = [
    # Example general freebies/deals blogs (choose trusted, legit, non-grey sources)
    "https://www.freecodecamp.org/news/rss/",  # learning freebies
]

def run(max_items=40):
    items = []
    for url in FEEDS:
        for e in fetch_rss(url, max_items=max_items):
            title = clean(e.get("title"))
            link = e.get("link")
            if not (title and link) or not allowed(title):
                continue
            items.append(Item(
                source="freebies_rss",
                title=title,
                url=link,
                summary=clean(e.get("summary")),
                posted_at=None,
                deadline=None,
                tags=["freebie"],
                meta={"feed": url},
            ))
    return items

src/sources/sample_custom.py

# Template for your own source module
from src.model import Item

def run(max_items=40):
    # Return a list[Item]
    return [
        Item(
            source="custom",
            title="Sample Opportunity",
            url="https://example.com/opportunity",
            summary="Short description...",
            posted_at=None,
            deadline=None,
            tags=["bounty"],
            meta={"note": "replace with real logic"},
        )
    ]

src/config.py

import os

def flag(name, default=True):
    raw = os.getenv(name, str(default)).lower().strip()
    return raw in ("1","true","yes","y","on")

CFG = {
    "MAX_ITEMS_PER_RUN": int(os.getenv("MAX_ITEMS_PER_RUN", 40)),
    "MIN_SCORE_TO_NOTIFY": float(os.getenv("MIN_SCORE_TO_NOTIFY", 0.55)),
    "JSON_FEED_PATH": os.getenv("JSON_FEED_PATH", "web/feed.json"),
    "ALLOW_AIRDROPS": flag("ALLOW_AIRDROPS", True),
    "ALLOW_GRANTS": flag("ALLOW_GRANTS", True),
    "ALLOW_HACKATHONS": flag("ALLOW_HACKATHONS", True),
    "ALLOW_FREEBIES": flag("ALLOW_FREEBIES", True),
}

src/main.py

import json, os
from pathlib import Path
from src.model import Item
from src.utils import db
from src.utils.text import clean, allowed
from src.notifiers import telegram, discord
from src.scoring import score_item
from src.config import CFG

# Register sources here
SOURCES = []
if CFG["ALLOW_AIRDROPS"]:
    from src.sources import crypto_airdrops as s1
    SOURCES.append(s1)
if CFG["ALLOW_GRANTS"]:
    from src.sources import grants_and_bounties as s2
    SOURCES.append(s2)
if CFG["ALLOW_HACKATHONS"]:
    from src.sources import hackathons as s3
    SOURCES.append(s3)
if CFG["ALLOW_FREEBIES"]:
    from src.sources import freebies_general as s4
    SOURCES.append(s4)


def notify(text: str):
    telegram.send(text)
    discord.send(text)


def main():
    db.init_db()
    collected: list[Item] = []
    for mod in SOURCES:
        try:
            items = mod.run(max_items=CFG["MAX_ITEMS_PER_RUN"])
            collected.extend(items)
        except Exception as e:
            notify(f"[lootbot] source error {mod.__name__}: {e}")

    # Scoring + Dedupe + Persist
    fresh = []
    for it in collected:
        if not allowed(it.title):
            continue
        it.title = clean(it.title)
        it.summary = clean(it.summary)
        it.score = score_item(it)
        item_id = db.make_id(it.source, it.url)
        if not db.seen(item_id):
            db.insert(it)
            fresh.append(it)

    fresh.sort(key=lambda x: x.score, reverse=True)

    # Save JSON feed for GitHub Pages
    feed_path = Path(CFG["JSON_FEED_PATH"]) 
    feed_path.parent.mkdir(parents=True, exist_ok=True)
    with open(feed_path, "w", encoding="utf-8") as f:
        json.dump([
            {
                "source": x.source,
                "title": x.title,
                "url": x.url,
                "summary": x.summary,
                "posted_at": x.posted_at,
                "deadline": x.deadline,
                "tags": x.tags,
                "score": x.score,
            }
            for x in fresh
        ], f, ensure_ascii=False, indent=2)

    # Notify top picks
    for it in fresh:
        if it.score >= CFG["MIN_SCORE_TO_NOTIFY"]:
            msg = f"🔥 {it.title}\n{it.url}\nTags: {', '.join(it.tags)} | Score: {it.score:.2f}"
            notify(msg)

if __name__ == "__main__":
    main()


---

6) Tiny Static Web UI (GitHub Pages)

web/index.html

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LootBot Zero — Feed</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial;max-width:920px;margin:2rem auto;padding:0 1rem}
    .card{border:1px solid #e5e7eb;border-radius:14px;padding:14px;margin:10px 0}
    .tag{display:inline-block;border:1px solid #ddd;border-radius:999px;padding:2px 8px;margin-right:6px;font-size:12px}
    .score{float:right;opacity:.75}
    a{color:#111}
  </style>
</head>
<body>
  <h1>LootBot Zero — Latest Opportunities</h1>
  <div id="list"></div>
  <script>
    async function run(){
      const res = await fetch('./feed.json?_=' + Date.now());
      const data = await res.json();
      const list = document.getElementById('list');
      list.innerHTML = '';
      data.forEach(x => {
        const el = document.createElement('div');
        el.className = 'card';
        el.innerHTML = `
          <div class="score">Score: ${x.score.toFixed(2)}</div>
          <h3><a href="${x.url}" target="_blank" rel="noopener">${x.title}</a></h3>
          <p>${x.summary||''}</p>
          <div>${(x.tags||[]).map(t=>`<span class='tag'>${t}</span>`).join('')}</div>
        `;
        list.appendChild(el);
      })
    }
    run();
  </script>
</body>
</html>


---

7) GitHub Actions (Free Runner)

.github/workflows/lootbot.yml

name: LootBot Zero

on:
  schedule:
    - cron: '*/30 * * * *'   # every 30 minutes
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run LootBot
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          MAX_ITEMS_PER_RUN: 50
          MIN_SCORE_TO_NOTIFY: 0.6
        run: |
          python -m src.main
      - name: Commit feed + db
        run: |
          git config user.name "lootbot-zero"
          git config user.email "actions@github.com"
          git add web/feed.json .lootbot.sqlite || true
          git commit -m "update feed" || echo "nothing to commit"
          git push
      - name: Publish to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./web

> Enable GitHub Pages: Settings → Pages → Build from gh-pages → Save.




---

8) Requirements

requirements.txt

feedparser==6.0.11
requests==2.32.3


---

9) Run Script (Local)

scripts/run_local.sh

#!/usr/bin/env bash
set -euo pipefail
python -m src.main
python scripts/build_feed.py

scripts/build_feed.py

# placeholder kept for extensibility; current feed built in main.py
print("feed built by main.py")


---

10) How to Add More Power (still $0)

More sources via RSS: most sites have hidden /feed or /rss. Add trusted ones under src/sources/ only if they allow it.

Reputation filters: maintain a curated allowlist of orgs; auto-downrank unknowns.

Deadline detection: regex parse for dates; auto-calc urgency.

Language expand: run summaries through simple heuristics to keep alerts short.

Duplicate resolver across sources: normalize URLs (strip UTMs) before hashing.

Retry queue: if a source fails, log & retry next run.



---

11) Ethical Guardrails

Only use public RSS/APIs and respect Terms of Service.

No CAPTCHA bypassing, no multi-account farming, no exploiting security flaws, and no automations that violate platform rules.

Focus on education-oriented, developer, and community opportunities; avoid gambling/NSFW.



---

12) Telegram Setup (Free)

1. DM @BotFather → /newbot → get TELEGRAM_BOT_TOKEN.


2. Add the bot to your private chat/group and grab your TELEGRAM_CHAT_ID (send a message to the bot, then call https://api.telegram.org/bot<token>/getUpdates once from a browser to see the chat id).


3. Put both into GitHub → Repo → Settings → Secrets and variables → Actions → New repository secret.




---

13) Discord Setup (Free)

1. Create a server → Integrations → Webhooks → New Webhook.


2. Copy the URL and store as DISCORD_WEBHOOK_URL in Actions Secrets.




---

14) Customize Sources (Your Niche)

Add a file under src/sources/your_source.py returning list[Item].

Import it in src/main.py like the others.



---

15) One-Line TL;DR

> Fork → add your secrets → enable Pages → the bot runs on a free schedule, ranks new legit opportunities, pushes a JSON feed, and pings you on Telegram/Discord — all with $0 spend.



